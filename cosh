#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import argparse
import os
import subprocess
import sys
import textwrap

from collections import OrderedDict


class ShellType(object):
    types = {}

    @classmethod
    def register_all(cls):
        for subcls in cls.__subclasses__():
            ShellType.types.update((sh, subcls) for sh in subcls.shells)

    @classmethod
    def quote_if_needed(cls, v):
        if len(v) == 0 or v[0] not in ('\'', '"'):
            v = cls.single_quote(v)
        return v

    @classmethod
    def env_var(cls, key, val, export=True):
        return (cls.var_export if export else cls.var_local).format(
            key=key,
            val=cls.quote_if_needed(val),
        )

    @classmethod
    def env_alias(cls, key, val):
        return cls.alias_format.format(
            key=key,
            val=cls.quote_if_needed(val),
        )

    @classmethod
    def env_path(cls, *paths):
        return cls.var_export.format(
            key='PATH',
            val=cls.double_quote(cls.path_sep.join(paths)),
        )

    @classmethod
    def var(cls, key):
        return cls.var_armour.format(key=key)

    @classmethod
    def double_quote(cls, s):
        return '"' + str(s).replace('"', '\\\"') + '"'

    @classmethod
    def single_quote(cls, s):
        return '\'' + str(s).replace('\'', '\\\'') + '\''


class Posix(ShellType):
    shells = ['posix', 'sh', 'bash', 'ash', 'dash', 'ksh', 'zsh']
    var_local = '{key}={val}'
    var_export = 'export {key}={val}'
    alias_format = 'alias {key}={val}'
    path_sep = ':'
    var_armour = '${{{key}}}'


class Fish(ShellType):
    shells = ['fish']
    var_local = 'set {key} {val}'
    var_export = 'set -x {key} {val}'
    alias_format = 'alias {key}={val}'
    path_sep = ' '
    var_armour = '${key}'

    @classmethod
    def quote_path_elements(cls, elem):
        return elem if elem == cls.var('PATH') else cls.double_quote(elem)

    @classmethod
    def env_path(cls, *paths):
        return cls.var_export.format(
            key='PATH',
            val=cls.path_sep.join(
                cls.quote_path_elements(elem) for elem in paths
            ),
        )


class Csh(ShellType):
    shells = ['csh', 'tcsh']
    var_local = 'set {key} {val};'
    var_export = 'setenv {key} {val};'
    alias_format = 'alias {key} {val};'
    path_sep = ':'
    var_armour = '${{{key}}}'

    @classmethod
    def double_quote(cls, s):
        return '"' + str(s).replace('"', '"\\""') + '"'


ShellType.register_all()


class EnvItem(object):
    def __init__(self, v):
        self.v = str(v)

    def render(self, k, shell):
        raise NotImplementedError


class Var(EnvItem):
    def render(self, k, shell):
        return shell.env_var(k, self.v)


class LVar(EnvItem):
    def render(self, k, shell):
        return shell.env_var(k, self.v, export=False)


class Alias(EnvItem):
    def render(self, k, shell):
        return shell.env_alias(k, self.v)


class ShellEnv(object):

    _env = OrderedDict()
    _osenv = {}
    _shell = None
    _default_type = Var

    def __init__(self, shell):
        self._osenv.update(os.environ)
        super(ShellEnv, self).__setattr__('_shell', shell)

    def __getitem__(self, k):
        try:
            return self._env[k].v
        except KeyError:
            return self._osenv[k]

    def __setitem__(self, k, v):
        if issubclass(type(v), EnvItem):
            self._env[k] = v
            print(v.render(k, self._shell))
        else:
            self._env[k] = self._default_type(v)
            print(self._env[k].render(k, self._shell))

    def __getattr__(self, k):
        return self[k]

    def __setattr__(self, k, v):
        self[k] = v

    def __contains__(self, k):
        return k in self._env or k in self._osenv

    def path_s(self, *v):
        print(self._shell.env_path(self._shell.var('PATH'), *v))

    def path_p(self, *v):
        print(self._shell.env_path(*(v + (self._shell.var('PATH'),))))


def run_command(*cmd):
    return subprocess.check_output(cmd).decode('utf-8').rstrip('\n')


def verbatim(s):
    print(textwrap.dedent(s).strip('\n'))


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Multi-shell environment generation utility'
    )

    parser.add_argument(
        '--shell', '-s',
        action='store',
        type=str,
        default='sh',
        help='target shell syntax',
    )

    parser.add_argument(
        'filename',
        action='store',
        type=str,
        nargs='?',
        help='configuration file',
    )

    results = parser.parse_args()
    shell_name = results.shell.lower()

    try:
        shell = ShellType.types[shell_name]
    except KeyError:
        raise ValueError('Unsupported shell {0}'.format(results.shell))

    if results.filename:
        istream = open(results.filename, 'r')
        conf = results.filename
    else:
        istream = sys.stdin
        conf = 'stdin-conf'

    shell_env = ShellEnv(shell)
    config_env = {
        'Alias': Alias,
        'LVar': LVar,
        'Var': Var,
        'Csh': Csh,
        'Fish': Fish,
        'Posix': Posix,
        'env': shell_env,
        'platform': sys.platform,
        'run': run_command,
        'shell': shell,
        'shell_name': shell_name,
        'verbatim': verbatim,
        'var': shell.var,
        'dq': shell.double_quote,
        'sq': shell.single_quote,
    }

    code = compile(istream.read(), conf, 'exec')
    if results.filename:
        istream.close()
    exec(code, config_env, config_env)
